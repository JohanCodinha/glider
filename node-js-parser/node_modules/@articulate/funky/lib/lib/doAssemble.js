var always    = require('ramda/src/always')
var cond      = require('ramda/src/cond')
var curry     = require('ramda/src/curry')
var curryN    = require('ramda/src/curryN')
var length    = require('ramda/src/length')
var map       = require('ramda/src/map')
var T         = require('ramda/src/T')
var transduce = require('ramda/src/transduce')
var values    = require('ramda/src/values')

var isTypeOf = curry(function (type, x) { return typeof x === type; })

var getAssembleLength = function (xfrms) { return transduce(map(getLength), Math.max, 0, values(xfrms)); }

var getLength = cond([
  [ isTypeOf('object'),   getAssembleLength ],
  [ isTypeOf('function'), length            ],
  [ T,                    always(0)         ] ])

var doAssemble = function (assemble, xfrms) {
  var x = [], len$1 = arguments.length - 2;
  while ( len$1-- > 0 ) x[ len$1 ] = arguments[ len$1 + 2 ];

  var len = getAssembleLength(xfrms)
  var fn = curryN(len + 1, assemble)
  if (x.length === 0) {
    if (len === 0) {
      // explicity return a function with arity 0 that will spread args
      return function () {
        var y = [], len = arguments.length;
        while ( len-- ) y[ len ] = arguments[ len ];

        return fn.apply(void 0, [ xfrms ].concat( y ));
      }
    }
    return fn(xfrms)
  }
  return fn.apply(void 0, [ xfrms ].concat( x ))
}

module.exports = curry(doAssemble)
