var always = require('ramda/src/always')
var apply = require('ramda/src/apply')
var compose = require('ramda/src/compose')
var cond = require('ramda/src/cond')
var curryN = require('ramda/src/curryN')
var fromPairs = require('ramda/src/fromPairs')
var identity = require('ramda/src/identity')
var is = require('ramda/src/is')
var map = require('ramda/src/map')
var pair = require('ramda/src/pair')
var T = require('ramda/src/T')
var toPairs = require('ramda/src/toPairs')

var doAssemble = require('./lib/doAssemble')
var juxtP = require('./juxtP')
var mapP = require('./mapP')

// assembleP :: { k: ((...v) -> Promise v) } -> (...v) -> Promise { k: v }
var assembleP = function (xfrms) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    return apply(handle(xfrms), args);
}

var _assembleP = curryN(2, assembleP)

var _assembleArrayP =
  compose(juxtP, map(_assembleP))

var _assembleObjP = function (xfrms) { return function () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var transformObj = function (ref) {
      var key = ref[0];
      var xfrm = ref[1];

      return Promise.resolve(args)
      .then(apply(handle(xfrm)))
      .then(pair(key));
  }

  return Promise.resolve(toPairs(xfrms))
    .then(mapP(transformObj))
    .then(fromPairs)
}; }

var handle =
  cond([
    [ is(Function), identity ],
    [ is(Array), _assembleArrayP ],
    [ is(Object), _assembleObjP ],
    [ T, always ]
  ])

module.exports = doAssemble(assembleP)
