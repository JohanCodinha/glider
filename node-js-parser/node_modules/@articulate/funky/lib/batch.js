var call    = require('ramda/src/call')
var curry   = require('ramda/src/curry')
var indexBy = require('ramda/src/indexBy')
var juxt    = require('ramda/src/juxt')
var max     = require('ramda/src/max')
var zipWith = require('ramda/src/zipWith')

// batch :: { k: v } -> ([a] -> Promise [b]) -> a -> Promise b
var batch = function (opts, f) {
  if ( opts === void 0 ) opts={};

  var inputKey = opts.inputKey;
  var limit = opts.limit; if ( limit === void 0 ) limit = Infinity;
  var outputKey = opts.outputKey;
  var wait = opts.wait; if ( wait === void 0 ) wait = 32;

  var matching = inputKey && outputKey

  var args     = []
  var last     = 0
  var rejects  = []
  var resolves = matching ? {} : []
  var timeout  = 0
  var uniq     = new Map()

  var addResolve = function (arg, res) { return matching ? (resolves[inputKey(arg)] = res) : resolves.push(res); }

  var batched = function (arg) {
    if (uniq.has(arg)) {
      return uniq.get(arg)
    } else {
      var promise = new Promise(function (res, rej) {
        args.push(arg)
        rejects.push(rej)
        addResolve(arg, res)
      })

      uniq.set(arg, promise)

      if (args.length >= limit) { run() }

      else if (!timeout) {
        var delta = new Date() - last
        timeout = setTimeout(run, max(0, wait - delta))
      }

      return promise
    }
  }

  var matchResolves = function (resolves) { return function (results) {
    var indexed = indexBy(outputKey, results)
    for (var key in resolves) { resolves[key](indexed[key]) }
  }; }

  var resolveAll =
    matching ? matchResolves : zipWith(call)

  var run = function () {
    Promise.resolve(args)
      .then(f)
      .then(resolveAll(resolves))
      .catch(juxt(rejects))

    clearTimeout(timeout)
    args     = []
    last     = +new Date()
    rejects  = []
    resolves = matching ? {} : []
    timeout  = 0
    uniq.clear()
  }

  return batched
}

module.exports = curry(batch)
